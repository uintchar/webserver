- [1. C++的特点与演化](#1-c的特点与演化)
- [2. 资源管理和对象的基本规则](#2-资源管理和对象的基本规则)
- [3. 移动语义与右值引用](#3-移动语义与右值引用)
- [4. 智能指针](#4-智能指针)
  - [4.1. 手写智能指针](#41-手写智能指针)
- [5. STL六大组件](#5-stl六大组件)
  - [5.1. 容器和类容器](#51-容器和类容器)
    - [5.1.1. string](#511-string)
    - [5.1.2. array](#512-array)
    - [5.1.3. vector](#513-vector)
    - [5.1.4. deque](#514-deque)
    - [5.1.5. list](#515-list)
    - [5.1.6. forward_list](#516-forward_list)
    - [5.1.7. queue](#517-queue)
    - [5.1.8. stack](#518-stack)
- [6. 对象返回和异常](#6-对象返回和异常)
- [7. 现代C++的易用性改进](#7-现代c的易用性改进)

# 1. C++的特点与演化

# 2. 资源管理和对象的基本规则

# 3. 移动语义与右值引用

```cpp {class=line-numbers}
对于下面的代码：
class Obj;
Obj getObj(int n);
void foo(Obj& obj); // (1)
void foo(Obj&& obj); // (2)
int main()
{
  Obj&& r = getObj(42);
  foo(r);
}

下面哪些陈述是对的？
标为 (1) 的 foo 将会被调用。**
标为 (2) 的 foo 将会被调用。
程序会有异常行为，因为调用 foo 时 getObj 返回的对象已经不存在。
程序行为是完全正常的，没有对对象的异常访问，也没有资源泄漏。**
```

# 4. 智能指针

## 4.1. 手写智能指针

```cpp {class=line-numbers}
下面哪个关于智能指针的描述是正确的？
1. 智能指针没有额外开销，可以代替普通指针的用法。
2. 在智能指针里我们优先选择shared_ptr，因为它比较好用、开销最低。
3. 在智能指针里shared_ptr的一个缺点是会牵涉到两次内存分配：对象本身和引用计数。两次成本无法避免。
4. 内存占用上unique_ptr通常跟普通指针的大小一样。(***)

下面哪个关于unique_ptr的陈述是错误的？
1. 函数可以返回一个 unique_ptr，然后直接赋给一个对应类型的变量。
2. 如果一个函数返回一个 unique_ptr，我们赋值给变量时应当使用 std::move 来进行移动。(***)
3. 一个 unique_ptr 的变量，不可以直接赋给另一个 unique_ptr 的变量。
4. 一个 unique_ptr 的变量，可以使用 std::move 来移动给另一个 unique_ptr 的变量。
```

# 5. STL六大组件

## 5.1. 容器和类容器

### 5.1.1. string

### 5.1.2. array

### 5.1.3. vector

### 5.1.4. deque

### 5.1.5. list

### 5.1.6. forward_list

### 5.1.7. queue

### 5.1.8. stack

```cpp {class=line-numbers}
下面哪些容器在中间插入新元素时性能可以达到均摊 O(1) 或更好？
1. list (***)
2. forward_list
3. deque
4. vector
```

# 6. 对象返回和异常

# 7. 现代C++的易用性改进