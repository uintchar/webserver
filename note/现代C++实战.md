- [1. C++的特点与演化](#1-c的特点与演化)
- [2. 资源管理和对象的基本规则](#2-资源管理和对象的基本规则)
- [3. 移动语义与右值引用](#3-移动语义与右值引用)
- [4. 智能指针](#4-智能指针)
  - [4.1. 手写智能指针](#41-手写智能指针)
- [5. STL六大组件](#5-stl六大组件)
  - [5.1. 容器和类容器](#51-容器和类容器)
    - [5.1.1. string](#511-string)
    - [5.1.2. array](#512-array)
    - [5.1.3. vector](#513-vector)
    - [5.1.4. deque](#514-deque)
    - [5.1.5. list](#515-list)
    - [5.1.6. forward_list](#516-forward_list)
    - [5.1.7. queue](#517-queue)
    - [5.1.8. stack](#518-stack)
- [6. 对象返回和异常](#6-对象返回和异常)
- [7. 现代C++的易用性改进](#7-现代c的易用性改进)
  - [7.1. 自动类型推导和类模板参数推导](#71-自动类型推导和类模板参数推导)
    - [7.1.1. auto](#711-auto)
    - [7.1.2. decltype](#712-decltype)
    - [7.1.3. 模板参数推导（C++17）](#713-模板参数推导c17)
  - [7.2. 类的特殊非静态成员函数和相关易用性改进](#72-类的特殊非静态成员函数和相关易用性改进)
  - [7.3. 初始化相关易用性改进](#73-初始化相关易用性改进)
    - [7.3.1. 列表初始化](#731-列表初始化)
    - [7.3.2. 类数据成员的默认初始化](#732-类数据成员的默认初始化)
    - [7.3.3. 自定义类的零初始化](#733-自定义类的零初始化)
  - [7.4. 其他易用性改进](#74-其他易用性改进)
    - [7.4.1. 用户定义字面量](#741-用户定义字面量)
    - [7.4.2. 二进制字面量](#742-二进制字面量)
    - [7.4.3. 数字分隔符](#743-数字分隔符)
    - [7.4.4. nullptr](#744-nullptr)
    - [7.4.5. 静态断言](#745-静态断言)
    - [7.4.6. if和switch中的变量初始化（C++17）](#746-if和switch中的变量初始化c17)
    - [7.4.7. override](#747-override)
    - [7.4.8. final](#748-final)
    - [7.4.9. 重要的标准属性（C++17）](#749-重要的标准属性c17)
- [8. 部分其他新特性](#8-部分其他新特性)
  - [8.1. using类型别名](#81-using类型别名)
  - [8.2. 定宽整数类型](#82-定宽整数类型)
  - [8.3. enum class](#83-enum-class)
  - [8.4. std::byte](#84-stdbyte)
  - [8.5. C++的字符和字符串类型](#85-c的字符和字符串类型)
  - [8.6. tuple和tie](#86-tuple和tie)
  - [8.7. 结构化绑定（C++17）](#87-结构化绑定c17)
  - [8.8. 时间（chrono）](#88-时间chrono)
  - [8.9. 随机数（random）](#89-随机数random)
  - [8.10. 正则表达式（regex）](#810-正则表达式regex)
- [9. any、optional、variant和错误处理](#9-anyoptionalvariant和错误处理)
  - [9.1. any](#91-any)
  - [9.2. optional](#92-optional)
  - [9.3. variant](#93-variant)
  - [9.4. 标准库的错误处理](#94-标准库的错误处理)
  - [9.5. Boost.Outcome](#95-boostoutcome)
- [10. 视图](#10-视图)
  - [10.1. string_view](#101-string_view)
  - [10.2. span](#102-span)
  - [10.3. Ranges里的视图](#103-ranges里的视图)
- [11. 模板基础](#11-模板基础)
- [12. 函数式编程](#12-函数式编程)
- [13. 编译器计算](#13-编译器计算)
- [14. 并发编程](#14-并发编程)
- [15. C++20与未来展望](#15-c20与未来展望)

# 1. C++的特点与演化

# 2. 资源管理和对象的基本规则

# 3. 移动语义与右值引用

转发引用？？？

```cpp {class=line-numbers}
对于下面的代码：
class Obj;
Obj getObj(int n);
void foo(Obj& obj); // (1)
void foo(Obj&& obj); // (2)
int main()
{
  Obj&& r = getObj(42);
  foo(r);
}

下面哪些陈述是对的？
标为 (1) 的 foo 将会被调用。**
标为 (2) 的 foo 将会被调用。
程序会有异常行为，因为调用 foo 时 getObj 返回的对象已经不存在。
程序行为是完全正常的，没有对对象的异常访问，也没有资源泄漏。**
```

# 4. 智能指针

## 4.1. 手写智能指针

```cpp {class=line-numbers}
下面哪个关于智能指针的描述是正确的？
1. 智能指针没有额外开销，可以代替普通指针的用法。
2. 在智能指针里我们优先选择shared_ptr，因为它比较好用、开销最低。
3. 在智能指针里shared_ptr的一个缺点是会牵涉到两次内存分配：对象本身和引用计数。两次成本无法避免。
4. 内存占用上unique_ptr通常跟普通指针的大小一样。(***)

下面哪个关于unique_ptr的陈述是错误的？
1. 函数可以返回一个 unique_ptr，然后直接赋给一个对应类型的变量。
2. 如果一个函数返回一个 unique_ptr，我们赋值给变量时应当使用 std::move 来进行移动。(***)
3. 一个 unique_ptr 的变量，不可以直接赋给另一个 unique_ptr 的变量。
4. 一个 unique_ptr 的变量，可以使用 std::move 来移动给另一个 unique_ptr 的变量。
```

# 5. STL六大组件

## 5.1. 容器和类容器

### 5.1.1. string

### 5.1.2. array

### 5.1.3. vector

### 5.1.4. deque

### 5.1.5. list

### 5.1.6. forward_list

### 5.1.7. queue

### 5.1.8. stack

```cpp {class=line-numbers}
下面哪些容器在中间插入新元素时性能可以达到均摊 O(1) 或更好？
1. list (***)
2. forward_list
3. deque
4. vector
```

# 6. 对象返回和异常

# 7. 现代C++的易用性改进

## 7.1. 自动类型推导和类模板参数推导

### 7.1.1. auto

### 7.1.2. decltype

### 7.1.3. 模板参数推导（C++17）

## 7.2. 类的特殊非静态成员函数和相关易用性改进

## 7.3. 初始化相关易用性改进

### 7.3.1. 列表初始化

### 7.3.2. 类数据成员的默认初始化

### 7.3.3. 自定义类的零初始化

## 7.4. 其他易用性改进

### 7.4.1. 用户定义字面量

### 7.4.2. 二进制字面量

### 7.4.3. 数字分隔符

### 7.4.4. nullptr

### 7.4.5. 静态断言

### 7.4.6. if和switch中的变量初始化（C++17）

### 7.4.7. override

### 7.4.8. final

### 7.4.9. 重要的标准属性（C++17）

# 8. 部分其他新特性

## 8.1. using类型别名

## 8.2. 定宽整数类型

## 8.3. enum class

## 8.4. std::byte

## 8.5. C++的字符和字符串类型

## 8.6. tuple和tie

## 8.7. 结构化绑定（C++17）

## 8.8. 时间（chrono）

## 8.9. 随机数（random）

## 8.10. 正则表达式（regex）

# 9. any、optional、variant和错误处理

## 9.1. any

## 9.2. optional

## 9.3. variant

## 9.4. 标准库的错误处理

## 9.5. Boost.Outcome

# 10. 视图

## 10.1. string_view

## 10.2. span

## 10.3. Ranges里的视图

# 11. 模板基础

# 12. 函数式编程

# 13. 编译器计算

# 14. 并发编程

# 15. C++20与未来展望

